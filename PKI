# Post on Public Key Infrastructure (PKI)

Let’s say there’s a spy named Alice who wants to send a confidential piece of information to Bob, her senior officer. 
She can’t send this information in plaintext as enemies could easily intercept and read/tamper with it.
That’s why she must send this information in an unreadable form that Bob will be able to derive, but their enemies won’t. In other words, Alice will need to encrypt the information. 
But here comes a problem. 
If Alice locks (encrypts) the message using a key (some logic), then how will Bob decrypt it? 

He must have the key with him, right? To give the key to Bob, there’s no option other than meeting with him face-to-face, which is totally impractical (to say the least) or to send it via courier and risk it being intercepted.
Such an encryption method is problematic not only in the physical world but also in the virtual world.
Every time two computers want to communicate securely, they’d have to agree on a single encryption key every single interaction.
This is a mathematical process and takes time. 
And if there’s a server (for example, a bank) that communicates with multiple users, then the server will have to perform a computational process for each client transaction, and that would slow it down even further. 
All of these things involve a variety of complex processes and agreements that must be handled at micro speed.
That’s where PKI comes in.

PKI also involves the use of a key pair — a public key and a private key — in a process that’s known intuitively known as public key encryption.
One of these keys encrypts information and the other decrypts it. 
Both these keys are distinct, but they’re mathematically related to each other.
It means that the information encrypted with one key can be decrypted only using the key associated with it. 
The public key, as the name implies, is available publicly. The private key, on the other hand, is kept private.

So, if Alice and Bob are using public key infrastructure instead of the symmetric encryption method, Alice could encrypt the secret message using Bob’s public key that she has. 
Bob, with his private key, is then the only person who can decrypt the message. 

The most popular use of PKI is in providing secure, encrypted communication between web browsers (clients) and web servers (websites). 

This is done by employing the HTTPS protocol, which is implemented by installing an SSL certificate on the web server.

What is an SSL/TLS Certificate?

When a computer connects to a website, communication begins between the computer's web browser and the web server the site is hosted on. 
Think of an SSL/TLS certificate as a driver’s license of sorts—it serves two functions. It grants permissions to use encrypted communication via Public Key Infrastructure, and also authenticates the identity of the certificate’s holder.

Authentication is done via the organization that issues the SSL certificate. 
These Certificate Authorities, as they are called, go through a validation process depending on which type of certificate a website is purchasing. 

SSL Certificates facilitate an encrypted connection between a browser and a web server while also authenticating the identity of the website that owns the cert. 
With an SSL/TLS certificate, it's important to remember that the end user is the one visiting the website, but they are not the one who owns the certificate itself–that belongs to the company operating the website.

How PKI Works in SSL/TLS?

1. First, when the client (browser) visits the web server upon request by the user, the client sends the server its supported cipher suites and compatible SSL/TLS version to initiate the connection. 
   This is regarded as a “client hello” message.

2. In return, the web server checks the cipher suites along with the SSL/TLS version and sends its public certificate to the client along with the “server hello” message.

3. On receiving the certificate file, the client (browser) authenticates it. If the certificate is found to be valid, the browser initiates the process of private key verification by encrypting the “pre-master secret/key” with the public key of the SSL/TLS certificate.

4. In return, the web server decrypts the pre-master secret with its private key.

5. Now, both the client and the server generate session keys from the client random, the server random, and the pre-master secret. This session key generated by both must be the same.

6. The client sends the “finished” message, encrypted with the session key.

7. The server sends the “finished” message, encrypted with the session key.

